{
    "apiVersion": "v1",
    "binaryData": {
        ".DS_Store": "AAAAAUJ1ZDEAABgAAAAIAAAAGAAAABALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAQAAAABAAAQAHNwYmxvYgAAAMlicAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAgLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAABAAAAQAAAAAEAAACAAAAAAQAAAQAAAAABAAACAAAAAAEAAAQAAAAAAAAAAAEAABAAAAAAAQAAIAAAAAABAABAAAAAAAEAAIAAAAAAAQABAAAAAAABAAIAAAAAAAEABAAAAAAAAQAIAAAAAAABABAAAAAAAAEAIAAAAAAAAQBAAAAAAAABAIAAAAAAAAEBAAAAAAAAAQIAAAAAAAABBAAAAAAAAAEIAAAAAAAAARAAAAAAAAABIAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEERFNEQgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAgAAAAYAAAAAAAAAABAAAAgAAAAAEAAAEAAAAAAQAAAgAAAAABAAAEAAAAAAEAAAgAAAAAAAAAAAEAACAAAAAAAQAAQAAAAAABAACAAAAAAAEAAQAAAAAAAQACAAAAAAABAAQAAAAAAAEACAAAAAAAAQAQAAAAAAABACAAAAAAAAEAQAAAAAAAAQCAAAAAAAABAQAAAAAAAAECAAAAAAAAAQQAAAAAAAABCAAAAAAAAAEQAAAAAAAAASAAAAAAAAABQAAAAAAAAAAZLgowHRAFCRBkCNQWFxgZMwo1ChAECRBzCdQWFxgZOAo6HRAGCRBLCNQWFxgZPQo/ChAACREB2wnUFhcYGQkdJgoICQgjQCgAAAAAAABUbmFtZSNAMAAAAAAAAAkACAAZAC4AQABIAFwAZQBwAHkAjACOAI8AogCrALoAxgDLANEA1gDeAOMA8AD5AP8BCQEPARcBGQEaAR0BHgEnASkBKgEsAS0BNgE4ATkBOwE8AUUBRwFIAUoBSwFUAVYBVwFZAVoBYwFlAWYBaAFpAXIBdAF1AXcBeAGBAYMBhAGHAYgBkQGSAZMBlAGdAaIBqwAAAAAAAAIBAAAAAAAAAEkAAAAAAAAAAAAAAAAAAAGsAAAAAwBiAGkAbnZTcm5sb25nAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    },
    "data": {
        "SocksClient.py": "#   _____            _         _____ _ _            _   \n#  / ____|          | |       / ____| (_)          | |  \n# | (___   ___   ___| | _____| |    | |_  ___ _ __ | |_ \n#  \\___ \\ / _ \\ / __| |/ / __| |    | | |/ _ \\ '_ \\| __|\n#  ____) | (_) | (__|   \u003c\\__ \\ |____| | |  __/ | | | |_ \n# |_____/ \\___/ \\___|_|\\_\\___/\\_____|_|_|\\___|_| |_|\\__|\n#\n#SocksClient v1.1a, for Proxying TCP connections by Nikos Vassakis\n#http://www.secforce.com / nikos.vassakis \u003cat\u003e secforce.com\n###############################################################\n\nfrom time import time, sleep, asctime\nimport socket\nimport select \nimport sys \nimport time\nimport getopt, struct\nimport threading, thread\n\nfrom settings import SocksServer_Defaults as Defaults\n\nDEBUG=0\n\nclass SocksClient():\t#TODO init:options\n\t#bufferSizeSize = size-4 - 4 bytes used for header\n\tdef __init__(self, portnumber, hostname='', bufferSize=Defaults['buffersize'], backlog=Defaults['backlog']):\n\t\tself.bufferSize=bufferSize-4\n\t\tself.error=0\n\t\tself.backlog = backlog\n\t\tself.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\tself.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\t\tself.server.bind((hostname,portnumber)) \n \t\tself.server.listen(self.backlog) \n\n\t\tself.debug = DEBUG\n\n\t\tprint \"[S] \",asctime(), \"Server Starts - %s:%s\" % ((hostname if hostname!='' else 'localhost'), portnumber)\t\n\t\t\n\t\tself.wrapper_channel = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\tself.wrapper_channel.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n\tdef connect(self,TunnaPort, event=None):\n\t\tif event:\n\t\t\tevent.wait()\n\t\ttry:\n\t\t\tself.wrapper_channel.connect(('localhost', TunnaPort)) \n\t\t\tsuccess=True\n\t\texcept Exception, e:\n\t\t\tprint 'something\\'s wrong Exception type is %s' % `e`\n\t\t\tsys.exit()\n\n\t\tself.iserver(self.server, self.wrapper_channel)\n\t\t\n\t\tself.server.close()\n\t\tself.wrapper_channel.close()\n\t\n\tdef sockReceive(self,s,size):\n\t\ttry:\n\t\t\tdata = s.recv(size)\n\t\t\twhile len(data) \u003c size and data:\n\t\t\t\tif self.debug \u003e1: print len(data) , size\n\t\t\t\tdata += s.recv((size-len(data)))\n\t\t\treturn data\n\t\texcept socket.error as e:\t#Socket error\n\t\t\tself.error=self.error+1\n\t\t\tself.printError(e)\n\t\t\tif self.error \u003e 20 : sys.exit()\n\t\t\tpass\n\n\tdef printError(self,e):\n\t\tprint '\\033[91m',e,'\\033[0m'\n\n\tdef srcPort(self,s):\n\t\treturn s.getpeername()[1]\n\n\tdef iserver(self,local_proxy_server,wrapper_channel):\t#add blocking to wrapper_channel\n\t\tdebug = DEBUG\n\t\tsockets = [local_proxy_server,wrapper_channel] \n\t\trunning = 1 \n\t\tSocketDict = {}\n\n\t\t#Multiple input -\u003e will get sent over http 1st byte of packet will be socket identifier\n\t\twhile running: \n\t\t\tinputready,outputready,exceptready = select.select(sockets,[],[]) \n\n\t\t\tfor s in inputready: \n\t\t\t\ttry:\n\t\t\t\t\tif debug \u003e 1: print \"[+] Open Sockets: \",len(sockets)-1\n\t\t\t\t\tif s == local_proxy_server: # Accept client connections\n\t\t\t\t\t\t# handle the server socket \n\t\t\t\t\t\tclient, address = self.server.accept() \n\t\t\t\t\t\tSocketDict[self.srcPort(client)]=client\n\t\t\t\t\t\tsockets.append(client)\n\t\t\t\t\t\tif debug \u003e 1: print \"Accepted Client lSrc: \"+str(self.srcPort(client))\n\n\t\t\t\t\telif s == wrapper_channel:\t# Receive response \n\t\t\t\t\t\thead = self.sockReceive(s,4)\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t(lSrc,size) = struct.unpack('!HH',head)\n\t\t\t\t\t\texcept struct.error as e:\n\t\t\t\t\t\t\tpass\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif debug \u003e 2: print \"\u003c R received \", \"lSrc: \", lSrc, \"size: \", size\n\n\t\t\t\t\t\tif size \u003e 0:\n\t\t\t\t\t\t\tdata = self.sockReceive(s,size)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif lSrc in SocketDict:\n\t\t\t\t\t\t\t\tif debug \u003e 2: print \"\\t relaying to lSrc: \", lSrc, 'len', len(data)\n\t\t\t\t\t\t\t\tSocketDict[lSrc].send(data)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tif debug \u003e 2: print \"\\t Received response for unknown port \" , str(lSrc) , len(data)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tif debug \u003e 2: print \"\\t Closing Socket: \", lSrc\n\t\t\t\t\t\t\t\tSocketDict[lSrc].close()\n\t\t\t\t\t\t\t\tsockets.remove(SocketDict[lSrc])\n\t\t\t\t\t\t\t\tdel SocketDict[lSrc]\n\n\t\t\t\t\telse: \t# handle all other sockets - lSrc\n\t\t\t\t\t\tlSrc=self.srcPort(s)\n\t\t\t\t\t\tdata = s.recv(self.bufferSize)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif debug \u003e 2: print \"\u003e L Received Data (client -\",lSrc,\") :\" , len(data)\n\t\t\t\t\t\tif len(data)\u003e0 and data: \n\t\t\t\t\t\t\tdata = struct.pack('!HH', self.srcPort(s),len(data)) + data\n\t\t\t\t\t\t\tif debug \u003e 2: print  \"\\t sending: \",len(data),\"\\tstruct:\", struct.pack('!HH', self.srcPort(s),len(data))\n\t\t\t\t\t\t\twrapper_channel.send(data) \n\t\t\t\t\t\tif len(data)==0: \n\t\t\t\t\t\t\tif debug \u003e 2: print \"\\t No data: Closing Socket: \", self.srcPort(s)\n\t\t\t\t\t\t\tdata = struct.pack('!HH', self.srcPort(s),len(data))\n\t\t\t\t\t\t\tif debug \u003e 2: print  \"\\t sending: \",len(data),\"\\tstruct:\", struct.pack('!HH', self.srcPort(s),len(data))\n\t\t\t\t\t\t\twrapper_channel.send(data) \n\t\t\t\t\t\t\tif s in sockets: \n\t\t\t\t\t\t\t\tdel SocketDict[self.srcPort(s)]\n\t\t\t\t\t\t\t\tsockets.remove(s)\n\t\t\t\t\t\t\t\ts.close()\t\n\t\t\t\texcept socket.error, (errno, e):# socket.error, KeyError:\n\t\t\t\t\tif errno != 107:\n\t\t\t\t\t\tself.printError(e)\n\t\t\t\t\tif errno == 107:\n\t\t\t\t\t\tpass\n\t\t\t\t\ttry:\n\t\t\t\t\t\tdel SocketDict[self.srcPort(s)]\n\t\t\t\t\t\tsockets.remove(s)\n\t\t\t\t\t\ts.close()\n\t\t\t\t\texcept:\n\t\t\t\t\t\tpass\n\t\t\t\t\tpass\n\t\t\t\texcept (KeyError, struct.error) as e:\n\t\t\t\t\tself.printError(e)\n\t\t\t\t\tpass\n\t\tserver.close()\n",
        "SocksServer.py": "import time\nimport socket\nimport select \nimport sys \nimport time\nimport struct\nimport threading, thread\n\nfrom settings import SocksServer_Defaults as Defaults\n\nDEBUG=2\n\nclass SocksServer():\n\t#bufferSizeSize = size-4 - 4 bytes used for header\n\tdef __init__(self, socket, event=threading.Event(), bufferSize=Defaults['buffersize']):\n\t\tself.debug=DEBUG\n\t\tself.bufferSize=bufferSize-4\n\t\tself.timeout=0.2\t#XXX:For Speed - requests are threaded now but no real gain\n\t\t\n\t\tself.lock = threading.Lock()\n\t\tself.server=socket\n\t\tself.event=event\n\t\n\t\tprint \"[S]\",time.asctime(), \"SOCKS Server Starts - %s:%s\" % (self.server.getsockname()[0], self.server.getsockname()[1])\n\t\n\tdef run(self):\n\t\tself.event.set() #all done\n\t\tself.server.listen(50)\n\t\tself.server.setblocking(True)\n\t\twrapper_channel, address = self.server.accept()\n\t\tself.iserver(wrapper_channel)\n\t\twrapper_channel.close()\n\n\tdef sockReceive(self,s,size):\t#Receive until we have the whole packet\n\t\ttry:\n\t\t\tdata = s.recv(size)\n\t\t\twhile len(data) \u003c size and data:\n\t\t\t\tif self.debug \u003e 2: print len(data) , size\n\t\t\t\tdata += s.recv((size-len(data)))\n\t\t\treturn data\n\t\texcept socket.error as e: #Socket error\n\t\t\t\tself.printError(e)\n\t\t\t\tpass\n\n\tdef printError(self,e):\t\t#Red Print\n\t\tprint '\\033[91m',e,sys.exc_info()[0],'\\033[0m'\n\n\tdef parse_socks(self,data):\t#Parses the Socks4a Headder\n\t\t#Based on Socks4a RFC\n\t\t\n\t\tuser_idx = data[8:].find('\\x00')\n\t\tfmt = '!BBH4s%ss' % (user_idx)\n\t\t#print \" Data: \\\\x\" + ('\\\\x'.join(x.encode('hex') for x in data)),\"fmt\",fmt\n\t\ttry:\n\t\t\t(version,command,port,ip,user) = struct.unpack(fmt,data[:8+user_idx])\n\t\texcept struct.error as e:\n\t\t\tself.printError(e)\n\t\t\tif self.debug \u003e2: print data\n\t\t\tif self.debug \u003e2: print \" Data: \\\\x\" + ('\\\\x'.join(x.encode('hex') for x in data))\n\t\t\treturn None\n\t\t\n\t\tif version != 4:\n\t\t\tprint \"[-] Unsupported version: \" + str(version)\n\t\t\treturn None\n\t\t\n\t\tif command != 1:\n\t\t\tprint \"[-] Unsupported command: \" + str(command)\n\t\t\treturn None\n\t\t#Get IP\n\t\tif ip[:3] == '\\x00\\x00\\x00' and ip[3:] != '\\x00':\t#SOCKS4a\n\t\t\t#print data[8+1+user_idx:].find('\\x00')\n\t\t\thost = data[8+user_idx+1:8+user_idx+1+data[8+user_idx+1:].find('\\x00')]\t\n\t\telse:\n\t\t\thost = socket.inet_ntoa(ip)\n\t\t\n\t\treturn (version,command,port,user,host)\n\n\tdef establishConnection(self,s,data,sockets,SocketDict,inSrcPort):\n\t\tgranted = '\\x00\\x5a\\x00\\x00\\x00\\x00\\x00\\x00' \t#Socks request granted response\n\t\trejected = '\\x00\\x5b\\x00\\x00\\x00\\x00\\x00\\x00'\t#Socks request rejected response\n\t\t\n\t\ttry:\n\t\t\t#Parse data\n\t\t\t(version,command,port,user,host) = self.parse_socks(data)\n\n\t\t\tif self.debug \u003e 2: print (version,command,port,user,host)\n\t\t\t\n\t\t\t#Connect to socket\n\t\t\toutSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\t\toutSock.settimeout(self.timeout)\n\t\t\toutSock.connect((host, port))\n\t\t\t\n\t\t\tif self.debug \u003e4: print \"[T] Establish connection locking 1\"\n\t\t\t\n\t\t\tself.lock.acquire()\n\t\t\ttry:\t\t\t\n\t\t\t\tsockets.append(outSock)\n\t\t\t\tSocketDict[self.srcPort(outSock)] = inSrcPort,outSock\t\t#Link incoming port to created socket\n\t\t\t\ts.send(struct.pack('!HH',inSrcPort,len(granted))+granted)\t#Send connection established responce\n\t\t\tfinally:\n\t\t\t\tif self.debug \u003e4: print \"[T] Establish connection releasing 1\"\n\t\t\t\tself.lock.release()\n\t\t\t\n\t\t\tif self.debug \u003e 0: print \"[S] Connection to \"+host+\" Established\"\n\t\texcept (TypeError,socket.error, KeyError) as e :\n\t\t\tprint \"[-] Socks: Rejected\", e\n\t\t\t\n\t\t\tif self.debug \u003e4: print \"[T] Establish connection locking 2\"\n\t\t\tself.lock.acquire()\n\t\t\ttry:\n\t\t\t\ts.send(struct.pack('!HH',inSrcPort,len(rejected))+rejected)\t#Send connection rejected responce (port closed)\n\t\t\tfinally:\n\t\t\t\tif self.debug \u003e4: print \"[T] Establish connection releasing 2\"\n\t\t\t\tself.lock.release()\n\t\t\tpass\n\n\tdef srcPort(self,s):\n\t\treturn s.getsockname()[1]\n\n\tdef findISocket(self, port, dictionary):\n\t\tfor (p, sock) in dictionary.itervalues():\n\t\t\tif p == port:\t\t\t\t\t\t\t\t#If inSrcPort number in list redirect to socket\n\t\t\t\tif self.debug \u003e 3: print \"\\t (Found -\",self.srcPort(sock),\") -Redirecting-\"\n\t\t\t\treturn sock\n\t\telse:\n\t\t\treturn False\n\t\n\tdef deleteISocket(self, socket,dictionary,sockets):\n\t\tdel dictionary[self.srcPort(socket)]\n\t\tsockets.remove(socket)\n\t\n\tdef iserver(self, wrapper_channel):\n\t\tsockets = [wrapper_channel] \n\t\tself.sockets=sockets\n\t\trunning = 1 \n\t\tSocketDict = {}\n\t\tdebug=DEBUG\n\n\t\twhile running: \n\t\t\tinputready,outputready,exceptready = select.select(sockets,[],[]) \n\t\t\tfor s in inputready:\n\t\t\t\ttry:\n\t\t\t\t\tif debug \u003e 2: print \"[+] Open Sockets: \",len(sockets)\n\t\t\t\t\tif s == wrapper_channel: # handle the input - main - socket \n\t\t\t\t\t\n\t\t\t\t\t\thead = self.sockReceive(s,4) #Tunna Head: First 4 bytes=incoming port and size of packet \n\t\t\t\t\t\t(inSrcPort,size) = struct.unpack('!HH',head)\n\t\t\t\t\t\tif debug \u003e 3: print \"\u003c L Received: \", \"inSrcPort: \", inSrcPort, \"size: \", size,\"\\n\\t\", struct.unpack('!HH',head)\n\n\t\t\t\t\t\tif size \u003e 0:\n\t\t\t\t\t\t\tdata = self.sockReceive(s,size)\n\t\t\t\t\t\t\toutSock=self.findISocket(inSrcPort,SocketDict)\n\t\t\t\t\t\t\tif outSock:\n\t\t\t\t\t\t\t\toutSock.send(data)\n\t\t\t\t\t\t\telse: # In socket not in list - Try Socks\n\t\t\t\t\t\t\t\tif debug \u003e 4: print \"[D] Starting Connection Thread\"\n\t\t\t\t\t\t\t\tThread = threading.Thread(\n\t\t\t\t\t\t\t\t\ttarget=self.establishConnection, args=(s,data,sockets,SocketDict,inSrcPort,)\n\t\t\t\t\t\t\t\t\t).start()\n\t\t\t\t\t\t\t\t#self.establishConnection(s,data,sockets,SocketDict,inSrcPort)\n\t\t\t\t\t\telse: #inSrcPort send no data - Port Closed \n\t\t\t\t\t\t\tif debug \u003e 3: print \"\\t Close Socket: \", inSrcPort\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\toutSock=self.findISocket(inSrcPort,SocketDict)\n\t\t\t\t\t\t\tif outSock:\n\t\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\tself.deleteISocket(outSock,SocketDict,sockets)\n\t\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\t\t\toutSock.close()\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telse: # Input socket not in list ?\n\t\t\t\t\t\t\t\tif debug \u003e 3: print \"[E] Received empty \u0026 socket not in list: \", inSrcPort\n\t\t\t\t\telse: # Other sockets (outSockets)\n\t\t\t\t\t\tdata = s.recv(self.bufferSize) \n\t\t\t\t\t\tif debug \u003e 3: print \"\u003e R Received: Data (client -\",self.srcPort(s),\") :\" , len(data) \n\t\t\t\t\t\t\n\t\t\t\t\t\tif data: \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif debug \u003e 3: print \"\\t sending to:\", SocketDict[self.srcPort(s)][0],\"len\", len(data)\n\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel locking 1\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\twrapper_channel.send((struct.pack('!HH',SocketDict[self.srcPort(s)][0],len(data))+data))\n\t\t\t\t\t\t\texcept (TypeError,socket.error, KeyError) as e:\n\t\t\t\t\t\t\t\tprint \"[-] Send Failed:\", e\n\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel releasing 1\"\n\t\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\t\n\t\t\t\t\t\tif len(data)==0:\n\t\t\t\t\t\t\tif debug \u003e 3: print \"\\tClosing port: \", SocketDict[self.srcPort(s)][0],'len:', len(data),\"Local Port:\", self.srcPort(s)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel locking 2\"\n\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\twrapper_channel.send((struct.pack('!HH',SocketDict[self.srcPort(s)][0],len(data)))) \t#send empty to lSrc will close the socket on the other end\n\t\t\t\t\t\t\texcept (TypeError,socket.error, KeyError) as e :\n\t\t\t\t\t\t\t\tself.printError(e)\n\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel releasing 2\"\n\t\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\tself.deleteISocket(s,SocketDict,sockets)\n\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\tself.lock.release()\n\n\t\t\t\t\t\t\ts.close()\n\t\t\t\texcept struct.error as e:\n\t\t\t\t\tprint \"[-] Received malformed packet: Closing Socks Proxy\"\n\t\t\t\t\tsys.exit()\n\t\t\t\texcept socket.error as e:\t#Kill misbehaving socket\n\t\t\t\t\tself.printError(e)\n\t\t\t\t\ttry:\n\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tself.deleteISocket(s,SocketDict,sockets)\n\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\ts.close()\n\t\t\t\t\texcept:\n\t\t\t\t\t\tpass\t\t\n\t\t\t\t\tpass\t\n\t\twrapper_channel.close()\n\n\tdef __del__(self):\n\t\tif hasattr(self,\"sockets\"):\n\t\t\tfor s in self.sockets:\n\t\t\t\ts.close()\n\t\t\t\t\n",
        "TunnaClient.py": "#Tunna v1.1a\nimport select\nimport urllib2, ssl\nimport cookielib\nimport gzip, zlib, StringIO\nfrom time import time, sleep, asctime\nimport threading, thread\nimport socket\nimport getopt, sys, os\nimport random,string\n\nfrom SocksClient import SocksClient\n\nDEBUG=0\n\nclass TunnaClient():\n\tdef __init__(self,options):\n\t\tself.options=options\n\t\tself.url = options['url']+\"?proxy\"\n\t\tself.local_port = options['local_port']\n\t\tremote_port = options['remote_port']\n\t\tself.bufferSize = options['bufferSize']\n\t\tself.penalty=0\n\t\tself.ptc=threading.Condition()\t#PingingThread wait for condition\n\t\t#init options\n\t\tremote_ip = options['remote_ip']\n\t\tself.ping_delay = options['ping_delay']\n\t\tself.start_p_thread = options['start_p_thread']\n\t\tself.verbose = options['verbose']\n\t\ttry:\n\t\t\t#init tunnel\n\t\t\tself.http=self.HTTPwrapper(self.url,self.options)\n\t\t\tself.mutex_http_req = threading.Lock()\n\t\t\tpings=0\n\t\texcept Exception, e:\n\t\t\tprint \"[-]\",e\n\t\t\tprint \"[-] Error Setting Up Tunnel\"\n\t\t\traise\n\t\tsleep(1)\n\n\tdef init_ping_thread(self,start=False):\t#Initialise thread\n\t\tself.pt = threading.Thread(name='ping', target=self.Pinging_Thread, args=())\n\t\tself.pt.setDaemon(1)\t\t\t\t#will exit if main exits\n\t\tif start:\n\t\t\tself.start_p_thread = True\n\t\t\tself.pt.start()\n\n\tdef Pinging_Thread(self):\n\t\tprint \"[+] Starting Ping thread\"\n\t\t#self.ptc=threading.Condition()\n\t\twait=True\n\t\tp=0.1\n\t\twhile 1:\t\t\t\t\t\t\t#loop forever\n\t\t\tif wait and (self.ping_delay \u003e 0):\n\t\t\t\tself.ptc.acquire()\n\t\t\t\tself.ptc.wait(self.ping_delay+self.penalty)\t\t#send ping to server interval + penalty\n\t\t\t\tself.ptc.release()\n\n\t\t\tself.mutex_http_req.acquire()\t\t#Ensure that the other thread is not making a request at this time\n\t\t\ttry:\n\t\t\t\tresp_data=self.http.HTTPreq(self.url,\"\")\t#Read response\n\t\t\t\tif self.verbose: self.http.v_print(pings_n=1)\n\t\t\t\tif self.penalty\u003c60: self.penalty+=p\t#Don't wait more than a minute\n\n\t\t\t\tif resp_data:\t\t\t\t\t\t\t\t#If response had data write them to socket\n\t\t\t\t\tself.penalty=0\n\t\t\t\t\tif self.verbose: self.http.v_print(received_d_pt=len(resp_data))\n\t\t\t\t\tself.TunnaSocket.send(resp_data)\t\t#write to socket\n\t\t\t\t\tresp_data=\"\"\t\t\t\t\t\t\t#clear data\n\t\t\t\t\twait=False\t\t\t\t\t\t\t\t#If data received don't wait\n\t\t\t\telse:\n\t\t\t\t\twait=True\n\t\t\texcept:\n\t\t\t\tself.TunnaSocket.close()\n\t\t\t\tthread.exit()\n\t\t\tfinally:\n\t\t\t\tself.mutex_http_req.release()\n\t\tprint \"[-] Pinging Thread Exited\"\n\t\t#Unrecoverable\n\t\tthread.interrupt_main()\t\t#Interupt main thread -\u003e exits\n\n\tdef startIfProxy(self):\n\t\tforceProxy=True\n\t\tprint \"[+] Checking for proxy:\",self.http.hasProxy\n\t\tif self.http.hasProxy and self.options['useSocks']:\n\t\t\t#If has proxy bind Tunna to random port \u0026 Proxy to Local_port\n\t\t\tself.event=threading.Event() \t#Receives Event when SocksClient is ready\n\t\t\tself.event.clear()\n\n\t\t\tself.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\t\tself.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\t\t\tself.server.bind((self.options['bind'],0))\n\n\t\t\tprint \"[+] Starting Socket Server\"\n\t\t\tS=SocksClient(self.local_port)\n\n\t\t\tSocksThread = threading.Thread(name='SocksThread', target=S.connect, args=(self.server.getsockname()[1],self.event))\n\t\t\tSocksThread.setDaemon(1)\t\t\t\t#will exit if main exits\n\t\t\tSocksThread.start()\n\t\telse:\n\t\t\t#Else bind Tunna to local_port\n\t\t\tself.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\t\tself.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\t\t\tself.server.bind((self.options['bind'],self.local_port))\n\n\tdef run(self):\n\t\tself.data=''\n\t\tself.startIfProxy()\n\t\tsockets = [self.server]\n\n\t\tif hasattr(self, 'event'):\n\t\t\tself.event.set()\n\t\tself.server.listen(0)\n\n\t\twhile True:\n\t\t\tinputready,outputready,exceptready = select.select(sockets,[],[])\n\n\t\t\tfor s in inputready:\n\t\t\t\tif s == self.server: # Accept client connections\n\t\t\t\t\tif hasattr(self, 'TunnaSocket'): \t# Only TunnaClient Should connect to the SocksClient\n\t\t\t\t\t\tt,a= self.server.accept()\n\t\t\t\t\t\tt.close\t\t\t\t\t\t\t# Drop the connection\n\t\t\t\t\telse:\n\t\t\t\t\t\tself.TunnaSocket, address = self.server.accept()\n\t\t\t\t\t\tself.init_ping_thread(self.start_p_thread)\n\t\t\t\t\t\tprint \"[T] Connected To Socks: \", self.TunnaSocket.getpeername()\n\t\t\t\t\t\tsockets.append(self.TunnaSocket)\n\n\t\t\t\telif s == self.TunnaSocket:\t# Receive response\n\t\t\t\t\tself.data = self.TunnaSocket.recv(self.bufferSize)\t#Read socket\n\t\t\t\t\tif len(self.data)==0:\n\t\t\t\t\t\tprint \"[-] Client Disconnected\"\n\t\t\t\t\t\tself.TunnaSocket.close()\n\t\t\t\t\t\tsockets.remove(self.TunnaSocket)\n\t\t\t\t\t\tself.handle_close()\n\n\t\t\t\t\tif self.data:\t\t\t\t\t\t#If data send them over HTTP (post)\n\t\t\t\t\t\tself.mutex_http_req.acquire()\t#Ensure that the other thread is not making a request at this time\n\n\t\t\t\t\t\tif self.start_p_thread == False:\t#Starts pinging thread (Will only run after first data is read from socket)\n\t\t\t\t\t\t\tself.start_p_thread = True\n\t\t\t\t\t\t\tself.pt.start()\n\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tif self.verbose: self.http.v_print(sent_d=len(self.data))\n\t\t\t\t\t\t\tresp_data=self.http.HTTPreq(self.url,self.data)\t\t#send data with a HTTP post\n\t\t\t\t\t\t\tif resp_data:\t\t\t\t\t\t\t#If data is received back write them to socket\n\t\t\t\t\t\t\t\tif self.verbose: self.http.v_print(received_d=len(resp_data))\n\t\t\t\t\t\t\t\tself.TunnaSocket.send(resp_data)\t\t\t\t#Write data to socket\n\t\t\t\t\t\t\t\tresp_data=\"\"\t\t\t\t\t\t#clear data\n\t\t\t\t\t\texcept socket.error, (errno, e):\n\t\t\t\t\t\t\tself.TunnaSocket.close()\n\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\tself.mutex_http_req.release()\n\t\t\t\t\t\t\t#if self.penalty \u003e 0:\n\t\t\t\t\t\t\tself.penalty=0\n\t\t\t\t\t\t\t#if data: stop pingThread wait\n\t\t\t\t\t\t\tself.ptc.acquire()\n\t\t\t\t\t\t\tself.ptc.notify()\t\t#send ping to server interval\n\t\t\t\t\t\t\tself.ptc.release()\n\n\t\t\tfor s in exceptready: #TODO?\n\t\t\t\tprint \"[-] Unhandled Socket Exception\"\n\n\tdef handle_close(self):\t\t\t#Client disconnected\n\t\tthread.interrupt_main()\n\n\tdef __del__(self):\n\t\tif hasattr(self, 'pt'):\n\t\t\t\tself.pt._Thread__stop()\t#Stop socket thread and exit\n\t\tif hasattr(self, 'http'):\n\t\t\tprint self.http.HTTPreq(self.url+\"\u0026close\")\n\t\t\tself.http.__del__()\n\t\tprint \"[-] Disconnected\"\n\n\tclass HTTPwrapper:\n\t\tcj = cookielib.CookieJar()\n\t\thasProxy=False\n\t\tneedsFile=False\n\t\tdef __init__(self, url , options):\n\t\t\tself.options=options\n\t\t\tremote_ip = options['remote_ip']\n\t\t\tremote_port = options['remote_port']\n\t\t\tverbose = options['verbose']\n\t\t\tself.cookie = options['cookie']\n                        self.bauth = options['bauth']\n\n\t\t\tself.url=url\n\n\t\t\tif verbose:\n\t\t\t\tself.send=0\n\t\t\t\tself.received=0\n\t\t\t\tself.received_pt=0\n\t\t\t\tself.pings=0\n\t\t\ttry:\n\t\t\t\tself.buildOpener()\n\t\t\t\t#Initial Request to get the cookie/options\n\t\t\t\tresp=str(self.HTTPreq(self.url))\n\t\t\t\tif self.options['useSocks']:\n\t\t\t\t\tif \"[PROXY]\" in resp:\n\t\t\t\t\t\tself.hasProxy=True\n\t\t\t\t\telif \"[FILE]\" in resp:\n\t\t\t\t\t\tprint \"[+] Sending File\"\n\t\t\t\t\t\tself.hasProxy=True\n\t\t\t\t\t\tif \"[WIN]\" in resp:\n\t\t\t\t\t\t\t(headers,data)=self.multipart_upload_file(self.options['ProxyFileWin'])\n\t\t\t\t\t\t\tprint self.HTTPreq((self.url+\"\u0026file\u0026upload\"),data,headers)\n\t\t\t\t\t\telif \"[LINUX]\" in resp:\n\t\t\t\t\t\t\t(headers,data)=self.multipart_upload_file(self.options['ProxyFilePy'])\n\t\t\t\t\t\t\tprint self.HTTPreq((self.url+\"\u0026file\u0026upload\"),data,headers)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint \"[-] Unknown server OS\"\n\n\t\t\t\t#2nd request: send connection options to webshell - In php this thread will stall\n\t\t\t\tself.t = threading.Thread(target=self.Threaded_request, args=(remote_port,remote_ip,self.options['useSocks']))\n\t\t\t\tself.t.start()\t\t#start the thread\n\n\t\t\texcept Exception, e:\n\t\t\t\tprint \"[-] Error:\",e\n\t\t\t\tthread.interrupt_main()\n\t\t\tsleep(2)\n\n\t\tdef buildOpener(self):\n\t\t\thandler=[urllib2.HTTPCookieProcessor(self.cj)]\n\t\t\tif self.options['upProxy']:# in self.options:\n\t\t\t\tif self.options['upProxyAuth']:# in self.options:\n\t\t\t\t\tfor h in self.options['upProxyAuth']:\n\t\t\t\t\t\thandler.append(h)\n\t\t\t\telse:\n\t\t\t\t\tif 'http://' in self.options['upProxy']:\n\t\t\t\t\t\thandler.append(urllib2.ProxyHandler({'http':self.options['upProxy']}))\n\t\t\t\t\telse:\n\t\t\t\t\t\thandler.append(urllib2.ProxyHandler({'https':self.options['upProxy']}))\n\n\t\t\tif self.options['ignoreServerCert']:\n\t\t\t\tctx = ssl.create_default_context()\n\t\t\t\tctx.check_hostname = False\n\t\t\t\tctx.verify_mode = ssl.CERT_NONE\n\t\t\t\thandler.append(urllib2.HTTPSHandler(context=ctx))\n\n\t\t\topener = urllib2.build_opener(*handler)\n\n\t\t\topener.addheaders = [('Accept-encoding', 'gzip')]\n\t\t\tself.opener = opener\n\n\t\tdef HTTPreq(self,url,data=None,headers=None):\n\t\t\topener=self.opener\n\n\t\t\tkargs={}\n\t\t\tkargs['url']=url\n\t\t\tif data:  kargs['data']=data\t#Will do a GET if no data else POST\n\t\t\tif headers:  kargs['headers']=headers\n\t\t\telse: kargs['headers']={'Content-Type':'application/octet-stream'}\n\n                        if self.options['cookie']:\n                            kargs['headers'].update({'Cookie':self.cookie})\n\n\t\t\tif self.options['bauth']:\n                            kargs['headers'].update({'Authorization': \"Basic %s\" % self.bauth})\n\n\t\t\t#Make Request\n\t\t\tf=opener.open(urllib2.Request(**kargs))\n\n\t\t\t#If response is gzip encoded\n\t\t\tif ('Content-Encoding' in f.info().keys() and f.info()['Content-Encoding']=='gzip') or \\\n\t\t\t\t('content-encoding' in f.info().keys() and f.info()['content-encoding']=='gzip'):\n\t\t\t\turl_f = StringIO.StringIO(f.read())\n\t\t\t\tdata = gzip.GzipFile(fileobj=url_f).read()\n\t\t\telse:\t#response not encoded\n\t\t\t\tdata = f.read()\n\n\t\t\tif f.getcode() != 200:\n\t\t\t\tprint \"[-] Received status code \" + str(f.getcode())\n\t\t\t\tprint data\n\t\t\t\tthread.interrupt_main()\n\t\t\treturn  data\t#Return response\n\n\t\tdef Threaded_request(self, remote_port,remote_ip=None, socks=True):\n\t\t\t#Sends connection options to the webshell\n\t\t\t#In php this thread will stall to keep the connection alive (will not receive response)\n\t\t\t#In other webshells [OK] is received\n\n\t\t\tprint '[+] Spawning keep-alive thread'\n\t\t\t#set up options\n\t\t\turl=self.url+\"\u0026port=\"+str(remote_port)\n\t\t\tif remote_ip:\turl+=\"\u0026ip=\"+str(remote_ip)\n\t\t\tif socks: \t\turl+=\"\u0026socks\"\n\t\t\t#send options\n\t\t\tresp = self.HTTPreq(url)\n\n\t\t\tif (resp[:4] == '[OK]'):\t#If ok is received (non-php webshell): Thread not needed\n\t\t\t\tprint '[-] Keep-alive thread not required'\n\t\t\telse:\t\t\t\t\t#if ok/proxy is not received something went wrong (if nothing is received: it's a PHP webshell)\n\t\t\t\tprint resp\n\t\t\t\tprint '[-] Keep-alive thread exited'\n\t\t\t\tthread.interrupt_main()\n\n\t\tdef multipart_upload_file(self,filename):\n\t\t\trand = ''.join([random.choice(\"0123456789\") for i in range(10)])\t#random_string (10)\n\n\t\t\ttmpFilename=rand[:3]+'-'+os.path.basename(filename)\n\n\t\t\theaders={'Content-Type':('multipart/form-data; boundary=---------------------------%s' % rand)}\n\n\t\t\tdata ='-----------------------------'+rand+\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t'\\r\\nContent-Disposition: form-data; name=\\\"proxy\\\"; filename=\\\"'+tmpFilename\t\t\\\n\t\t\t\t+'\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n'+(open(filename,'rb').read())\t\\\n\t\t\t\t+'\\r\\n-----------------------------'+rand+'--\\r\\n\\r\\n'\n\n\t\t\treturn headers,data\n\n\t\tdef v_print(self, sent_d=0, received_d=0, received_d_pt=0,pings_n=0):\t#Verbose output for Debugging\n\t\t\tself.send\n\t\t\tself.received\n\t\t\tself.received_pt\n\t\t\tself.pings\n\n\t\t\tself.send+=sent_d\n\t\t\tself.received+=received_d\n\t\t\tself.received_pt+=received_d_pt\n\t\t\tself.pings+=pings_n\n\n\t\t\tif sys.platform.startswith('win') or sys.platform == 'cygwin':\n\t\t\t\tos.system(\"cls\")\n\t\t\telse:\n\t\t\t\tos.system(\"clear\")\n\t\t\tsys.stdout.write(\n\t\t\t\t\"Received Data: %d (%d)\\nReceived Data From Ping Thread: %d (%d) \\nSent data: %d (%d) \\nPings sent: %d\\r\\n\"\n\t\t\t\t% (self.received,received_d, self.received_pt,received_d_pt, self.send, sent_d, self.pings) )\n\t\t\tsys.stdout.flush()\n\n\t\tdef __del__(self):\n\t\t\tif hasattr(self, 't') and self.t.isAlive:self.t._Thread__stop()\n\n",
        "__init__.py": "",
        "proxy.py": "#!/usr/bin/python\n#  _____\n# |_   _|   _ _ __  _ __   __ _\n#   | || | | | '_ \\| '_ \\ / _` |\n#   | || |_| | | | | | | | (_| |\n#   |_| \\__,_|_| |_|_| |_|\\__,_|\n#\n#Tunna v1.1a, for HTTP tunneling TCP connections by Nikos Vassakis\n#http://www.secforce.com / nikos.vassakis \u003cat\u003e secforce.com\n########################################################################\n#Tested with Python 2.6.5\n\nfrom time import time, sleep, asctime\nimport threading, thread\nimport optparse\nimport sys\nimport urllib2\nfrom base64 import b64encode\nfrom TunnaClient import TunnaClient\n\nfrom settings import Tunna_Defaults as Defaults\n\nDEBUG=0\n\ndef banner():\n\tprint \"  _____                        \"\n\tprint \" |_   _|   _ _ __  _ __   __ _ \"\n\tprint \"   | || | | | '_ \\\\| '_ \\\\ / _` |\"\n\tprint \"   | || |_| | | | | | | | (_| |\"\n\tprint \"   |_| \\\\__,_|_| |_|_| |_|\\\\__,_|\"\n\tprint \"\"\n\n\tprint  \"Tunna v1.1a, for HTTP tunneling TCP connections by Nikos Vassakis\"\n\tprint  \"http://www.secforce.com / nikos.vassakis \u003cat\u003e secforce.com\"\n\tprint \"###############################################################\"\n\tprint \"\"\n\ndef main():\n\tbanner()\n\tparser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter())\n\n\tparser.set_usage(\"python proxy.py -u \u003cremoteurl\u003e -l \u003clocalport\u003e [options]\")\n\n\tparser.add_option('-u','--url', help='url of the remote webshell', dest='url', action='store')\n\tparser.add_option('-l','--lport', help='local listening port', dest='local_port', action='store', type='int')\n\t#Verbosity\n\tparser.add_option('-v','--verbose', help='Verbose (outputs packet size)', dest='verbose', action='store_true',default=Defaults['verbose'])\n\t#Legacy options\n\tlegacyGroup = optparse.OptionGroup(parser, \"No SOCKS Options\",\"Options are ignored if SOCKS proxy is used\")\n\tlegacyGroup.add_option('-n','--no-socks', help='Do not use Socks Proxy', dest='useSocks', action='store_false',default=Defaults['useSocks'])\n\tlegacyGroup.add_option('-r','--rport', help='remote port of service for the webshell to connect to', dest='remote_port', action='store', type='int',default=Defaults['remote_port'])\n\tlegacyGroup.add_option('-a','--addr', help='address for remote webshell to connect to (default = 127.0.0.1)', dest='remote_ip', action='store',default=Defaults['remote_ip'])\n\tparser.add_option_group(legacyGroup)\n\t#Proxy options\n\tproxyGroup = optparse.OptionGroup(parser, \"Upstream Proxy Options\", \"Tunnel connection through a local Proxy\")\n\tproxyGroup.add_option('-x','--up-proxy', help='Upstream proxy (http://proxyserver.com:3128)', dest='upProxy', action='store', default=Defaults['upProxy'])\n\tproxyGroup.add_option('-A','--auth', help='Upstream proxy requires authentication', dest='upProxyAuth', action='store_true', default=Defaults['upProxyAuth'])\n\tparser.add_option_group(proxyGroup)\n\t#Advanced options\n\tadvancedGroup = optparse.OptionGroup(parser, \"Advanced Options\")\n\tparser.add_option('-b','--buffer', help='HTTP request size (some webshels have limitations on the size)', dest='bufferSize', action='store', type='int', default=Defaults['bufferSize'])\n\tadvancedGroup.add_option('-q','--ping-interval', help='webshprx pinging thread interval (default = 0.5)', dest='ping_delay', action='store', type='float', default=Defaults['ping_delay'])\n\tadvancedGroup.add_option('-s','--start-ping', help='Start the pinging thread first - some services send data first (eg. SSH)', dest='start_p_thread', action='store_true', default=Defaults['start_p_thread'])\n\tadvancedGroup.add_option('-c','--verify-server-cert', help='Verify Server Certificate', dest='start_p_thread', action='store_false', default=Defaults['ignoreServerCert'])\n\tadvancedGroup.add_option('-C','--cookie', help='Request cookies', dest='cookie', action='store')\n        advancedGroup.add_option('-t','--authentication', help='Basic authentication (username:password or \\'-\\' for stdin input', dest='bauth', action='store', default='no')\n\n\tparser.add_option_group(advancedGroup)\n\n\t(args, opts) = parser.parse_args()\n\n\toptions=dict(Defaults.items() + vars(args).items()) if args else Defaults\t#If missing options use Default\n\n\tif options['remote_port']:\n\t\toptions['useSocks']=False\n\n\tif not options['local_port']:\n\t\tparser.print_help()\n\t\tparser.error(\"Missing local port\")\n\tif not options['url']:\n\t\tparser.print_help()\n\t\tparser.error(\"Missing URL\")\n\tif options['upProxyAuth']:\t#Upstream Proxy requires authentication\n\t\tusername=raw_input(\"Proxy Authentication\\nUsername:\")\n\t\tfrom getpass import getpass\n\t\tpasswd=getpass(\"Password:\")\n\n\t\tif not options['upProxy']:\n\t\t\tparser.error(\"Missing Proxy URL\")\n\t\telse:\n\t\t\tfrom urlparse import urlparse\n\t\t\tu=urlparse(options['upProxy'])\n\t\t\tprx=\"%s://%s:%s@%s\" % (u.scheme,username,passwd,u.netloc)\n\n\t\t\tpassword_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()\n\t\t\tpassword_mgr.add_password(None,prx,username,passwd)\n\n\t\t\tproxy_handler = urllib2.ProxyHandler({u.scheme:prx})\n\t\t\tproxy_basic_handler = urllib2.ProxyBasicAuthHandler(password_mgr)\n\t\t\tproxy_digest_handler = urllib2.ProxyDigestAuthHandler(password_mgr)\n\n\t\t\toptions['upProxyAuth']=[proxy_handler,proxy_basic_handler,proxy_digest_handler]\n        if not options['bauth'] == 'no':            # Basic authentication\n            if options['bauth'] == '-':\n                username=raw_input(\"Basic Authentication\\nUsername:\")\n                from getpass import getpass\n                passwd=getpass(\"Password:\")\n            else:\n                username, passwd = options['bauth'].split(':')\n\n            options['bauth'] = b64encode('%s:%s' % (username, passwd))\n\n\ttry:\n\t\tT=TunnaClient(options)\n\t\tTunnaThread = threading.Thread(name='TunnaThread', target=T.run(), args=(options,))\n\t\tTunnaThread.start()\n\n\t\twhile True:\n\t\t\tsleep(10)\n\n\texcept (KeyboardInterrupt, SystemExit) as e:\n\t\tprint '[!] Received Interrupt or Something Went Wrong'\n\t\tif DEBUG \u003e 0:\n\t\t\timport traceback\n\t\t\tprint traceback.format_exc()\n\n\t\tif 'T' in locals():\n\t\t\tT.__del__()\n\t\tif 'TunnaThread' in locals() and TunnaThread.isAlive(): TunnaThread._Thread__stop()\n\t\tsys.exit()\n\texcept Exception as e:\n\t\tif DEBUG \u003e 0:\n\t\t\timport traceback\n\t\t\tprint traceback.format_exc()\n\t\tprint \"General Exception:\",e\n\ndef startTunna(options):\n\tT=TunnaClient(options)\n\tT.run()\n\nif __name__ == \"__main__\":\n\tmain()\n\n",
        "settings.py": "Tunna_Defaults ={\n\t#Default Tunna Settings\n\t'bufferSize':1024*8,\t# Size of Socket Buffer\n\t'verbose':False,\t# Verbose Print\n\t'ping_delay':0.5,\t# Delay between requests\n\t'interval':0.2,\n\t'bind':'0.0.0.0', \t# Change to localhost for binding Tunna to localport\t\n\t'useSocks':True,\t# Will use Socks Proxy if available\n\t'ignoreServerCert':True,\n\t\n\t# Default Remote Settings\n\t'local_port':0,\n\t'remote_port':0,\n\t'remote_ip':\"127.0.0.1\",\n\t'start_p_thread':False,\t# Start quering the socket first (eg. for SSH)\n\n\t#Set Up a Local Proxy\n\t'upProxy':None,\t#autodetect\n\t'upProxyAuth':None,\n\n\t#! Not to be changed\n\t'ProxyFileWin':'socks4aServer.exe',\n\t'ProxyFilePy':'socks4aServer.py',\n\n\t#! HTTP headers\n\t'Cookie':'',\n}\n\nWebserver_Defaults ={\n\t#Default WebServer Settings\n\t'hostname':\"0.0.0.0\",\t#Change to localhost for local connection\n\t'webServerPort':8000,\n\t'ssl':False,\n\n\t# For Debug purposes\n\t'WDEBUG':2,\n\t'USEFILE':False,\n\t\n\t#SSL Certificate\n\t'certificate':'''\n-----BEGIN PRIVATE KEY-----\nMIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAOKdz+7Zm+Fjq6qw\n4rwDvRl7XLwR2CNclfXlH3Ff8eLEZDpiEqJs47zKHAYBF5aEevIRGYMqbsErUYCC\nGu504KxZOgGoGmd8r3oDbqJp0pPovMbVPZOV0Ms+Q1fAHHfBN5+lLm3eovhVQ54G\n4ADHjU2P8BJ21VEkwBf5y35vNAkLAgMBAAECgYEAq9O1AgoF49RLKdWNVboP++5J\n1mBBXi6plhTwzmpNYgA/bvVF49pko5UrwnG5jOtOvZSxn37hE57g4WvFN+FvKFF2\nPFO3X4Shg4Rn84ZejoOhGs2KeGodZ/UbeU1qKm6N4kvLUPLFyyCnT875MbfXUozh\nPy+iaRzntvfBrSokyiECQQD+7EUcpeecMfIrRXVJxpak0HbscxvwfWAcKkt3a500\nQ7w8jkWeLyrb2jmoTVnsp89kzR2CyZkuUOWQHrpSmR4FAkEA45Ls5jBgfhY/doHe\nb5l41XjMN6WnPqxeMx9CRQFDRXcw/DRGrW2m5/SRptYS+W46aW6v39J3+0sYHv3z\n4SonzwJAR8IackYBPGaS1LtomKveG+bSkxyT8M5aD5OYSrVwOxYWFrW1wyFj3x8+\nu7GKbqOOLcHPXNGC3RbIiBkeOcIAQQJACzETk3J3nFvNvS8/2C8tARqSuH3eDrf9\nXfhAkxIv07+72ftcKnVFCw09CH5oqnmgR8UYwyIfom0b/5IvpzgigwJBAJSiZXBJ\nLsaVAOBetNmymX/EMoQEqNZCqi2ajVMwQEkXEnAOIz7sj1GGBdm4UMy+dCy4hR/V\nEY6wtgLRqgpaUN0=\n-----END PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\nMIICMjCCAZugAwIBAgIJAKKavRy2ij+ZMA0GCSqGSIb3DQEBBQUAMDIxCzAJBgNV\nBAYTAkdCMRMwEQYDVQQIDApTb21lLVN0YXRlMQ4wDAYDVQQKDAVUdW5uYTAeFw0x\nNDA3MDMxMzQ2MzNaFw0xNTA3MDMxMzQ2MzNaMDIxCzAJBgNVBAYTAkdCMRMwEQYD\nVQQIDApTb21lLVN0YXRlMQ4wDAYDVQQKDAVUdW5uYTCBnzANBgkqhkiG9w0BAQEF\nAAOBjQAwgYkCgYEA4p3P7tmb4WOrqrDivAO9GXtcvBHYI1yV9eUfcV/x4sRkOmIS\nomzjvMocBgEXloR68hEZgypuwStRgIIa7nTgrFk6AagaZ3yvegNuomnSk+i8xtU9\nk5XQyz5DV8Acd8E3n6Uubd6i+FVDngbgAMeNTY/wEnbVUSTAF/nLfm80CQsCAwEA\nAaNQME4wHQYDVR0OBBYEFNlKP/pXnWoVqmxDwmSFSjTBbDnFMB8GA1UdIwQYMBaA\nFNlKP/pXnWoVqmxDwmSFSjTBbDnFMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEF\nBQADgYEAM4CnP9QXKHljQ/gCble052+LfSwPWryRjwxTy3qlEpmSKb4UT6GlqABV\nCm2clM978TeCgsvOqsYya5iza/Gp8miKCmQ6WWxxiSm/J7QVHcaWIK9hqoPC6AXa\nI9iUqOJ9Esv2NuHYxG4XWtYfyttktIJcuAhQ/3IfZZJ9SKZTIPs=\n-----END CERTIFICATE-----\n\t'''\n}\n\nSocksServer_Defaults={\n\t'buffersize':1024*8,\n\t'backlog':10\n}\n\n",
        "socks4aServer.py": "#!/usr/bin/python\n#   _____            _         _____                          \n#  / ____|          | |       / ____|                         \n# | (___   ___   ___| | _____| (___   ___ _ ____   _____ _ __ \n#  \\___ \\ / _ \\ / __| |/ / __|\\___ \\ / _ \\ '__\\ \\ / / _ \\ '__|\n#  ____) | (_) | (__|   \u003c\\__ \\____) |  __/ |   \\ V /  __/ |   \n# |_____/ \\___/ \\___|_|\\_\\___/_____/ \\___|_|    \\_/ \\___|_|  \n#\n#SocksServer v1.1a, for Proxying TCP connections by Nikos Vassakis\n#http://www.secforce.com / nikos.vassakis \u003cat\u003e secforce.com\n########################################################################\n#Tested with Python 2.6.5\n\nimport getopt, sys\nimport socket\nimport select \nimport sys \nimport time\nimport struct\nimport threading, thread\n\nDEBUG=1 #Change to 0 for no output\n\nDefaults={\n\t'hostname':'localhost',\n\t'webServerPort':0,\n\t'timeout':0.5,\t#TODO: Not implemented\n\t'bufferSize':1024*8\n}\n\nclass SocksServer():\n\t#bufferSizeSize = 1024-4\n\n\tdef __init__(self, socket, event=threading.Event(), bufferSize=Defaults['bufferSize']):\n\t\tself.debug=DEBUG\n\t\tself.bufferSize=bufferSize-4\n\t\tself.timeout=1\t#XXX:For Speed - requests are threaded now but no real gain\n\t\t\n\t\tself.lock = threading.Lock()\n\t\tself.server=socket\n\t\tself.event=event \n\t\n\t\tif self.debug \u003e 0: print \"[S]\",time.asctime(), \"Server Starts - %s:%s\" % (self.server.getsockname()[0], self.server.getsockname()[1])\n\t\n\tdef run(self):\n\t\tself.event.set() #all done\n\t\tself.server.listen(50)\n\t\tself.server.setblocking(True)\n\t\twrapper_channel, address = self.server.accept()\n\t\tself.iserver(wrapper_channel)\n\t\twrapper_channel.close()\n\n\tdef sockReceive(self,s,size):\t#Receive until we have the whole packet\n\t\ttry:\n\t\t\tdata = s.recv(size)\n\t\t\twhile len(data) \u003c size and data:\n\t\t\t\tif self.debug \u003e 2: print len(data) , size\n\t\t\t\tdata += s.recv((size-len(data)))\n\t\t\treturn data\n\t\texcept socket.error as e: #Socket error\n\t\t\t\tself.printError(e)\n\t\t\t\tpass\n\n\tdef printError(self,e):\t\t#Red Print\n\t\tprint '\\033[91m',e,sys.exc_info()[0],'\\033[0m'\n\n\tdef parse_socks(self,data):\t#Parses the Socks4a Headder\n\t\t#Based on Socks4a RFC\n\t\t\n\t\tuser_idx = data[8:].find('\\x00')\n\t\tfmt = '!BBH4s%ss' % (user_idx)\n\t\t#print \" Data: \\\\x\" + ('\\\\x'.join(x.encode('hex') for x in data)),\"fmt\",fmt\n\t\ttry:\n\t\t\t(version,command,port,ip,user) = struct.unpack(fmt,data[:8+user_idx])\n\t\texcept struct.error as e:\n\t\t\tself.printError(e)\n\t\t\tif self.debug \u003e2: print data\n\t\t\tif self.debug \u003e2: print \" Data: \\\\x\" + ('\\\\x'.join(x.encode('hex') for x in data))\n\t\t\treturn None\n\t\t\n\t\tif version != 4:\n\t\t\tprint \"[-] Unsupported version: \" + str(version)\n\t\t\treturn None\n\t\t\n\t\tif command != 1:\n\t\t\tprint \"[-] Unsupported command: \" + str(command)\n\t\t\treturn None\n\t\t#Get IP\n\t\tif ip[:3] == '\\x00\\x00\\x00' and ip[3:] != '\\x00':\t#SOCKS4a\n\t\t\t#print data[8+1+user_idx:].find('\\x00')\n\t\t\thost = data[8+user_idx+1:8+user_idx+1+data[8+user_idx+1:].find('\\x00')]\t\n\t\telse:\n\t\t\thost = socket.inet_ntoa(ip)\n\t\t\n\t\treturn (version,command,port,user,host)\n\n\tdef establishConnection(self,s,data,sockets,SocketDict,inSrcPort):\n\t\tgranted = '\\x00\\x5a\\x00\\x00\\x00\\x00\\x00\\x00' \t#Socks request granted response\n\t\trejected = '\\x00\\x5b\\x00\\x00\\x00\\x00\\x00\\x00'\t#Socks request rejected response\n\t\t\n\t\ttry:\n\t\t\t#Parse data\n\t\t\t(version,command,port,user,host) = self.parse_socks(data)\n\n\t\t\tif self.debug \u003e 2: print (version,command,port,user,host)\n\t\t\t\n\t\t\t#Connect to socket\n\t\t\toutSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\t\toutSock.settimeout(self.timeout)\n\t\t\toutSock.connect((host, port))\n\t\t\t\n\t\t\tif self.debug \u003e4: print \"[T] Establish connection locking 1\"\n\t\t\t\n\t\t\tself.lock.acquire()\n\t\t\ttry:\t\t\t\n\t\t\t\tsockets.append(outSock)\n\t\t\t\tSocketDict[self.srcPort(outSock)] = inSrcPort,outSock\t\t#Link incoming port to created socket\n\t\t\t\ts.send(struct.pack('!HH',inSrcPort,len(granted))+granted)\t#Send connection established responce\n\t\t\tfinally:\n\t\t\t\tif self.debug \u003e4: print \"[T] Establish connection releasing 1\"\n\t\t\t\tself.lock.release()\n\t\t\t\n\t\t\tif self.debug \u003e 0: print \"[S] Connection to \"+host+\" Established\"\n\t\texcept (TypeError,socket.error, KeyError) as e :\n\t\t\tprint \"[-] Socks: Rejected\", e\n\t\t\t\n\t\t\tif self.debug \u003e4: print \"[T] Establish connection locking 2\"\n\t\t\tself.lock.acquire()\n\t\t\ttry:\n\t\t\t\ts.send(struct.pack('!HH',inSrcPort,len(rejected))+rejected)\t#Send connection rejected responce (port closed)\n\t\t\tfinally:\n\t\t\t\tif self.debug \u003e4: print \"[T] Establish connection releasing 2\"\n\t\t\t\tself.lock.release()\n\t\t\tpass\n\n\tdef srcPort(self,s):\n\t\treturn s.getsockname()[1]\n\n\tdef findISocket(self, port, dictionary):\n\t\tfor (p, sock) in dictionary.itervalues():\n\t\t\tif p == port:\t\t\t\t\t\t\t\t#If inSrcPort number in list redirect to socket\n\t\t\t\tif self.debug \u003e 3: print \"\\t (Found -\",self.srcPort(sock),\") -Redirecting-\"\n\t\t\t\treturn sock\n\t\telse:\n\t\t\treturn False\n\t\n\tdef deleteISocket(self, socket,dictionary,sockets):\n\t\tdel dictionary[self.srcPort(socket)]\n\t\tsockets.remove(socket)\n\t\n\tdef iserver(self, wrapper_channel):\n\t\tsockets = [wrapper_channel] \n\t\tself.sockets=sockets\n\t\trunning = 1 \n\t\tSocketDict = {}\n\t\tdebug=DEBUG\n\n\t\twhile running: \n\t\t\tinputready,outputready,exceptready = select.select(sockets,[],[]) \n\t\t\tfor s in inputready:\n\t\t\t\ttry:\n\t\t\t\t\tif debug \u003e 2: print \"[+] Open Sockets: \",len(sockets)\n\t\t\t\t\tif s == wrapper_channel: # handle the input - main - socket \n\t\t\t\t\t\n\t\t\t\t\t\thead = self.sockReceive(s,4) #Tunna Head: First 4 bytes=incoming port and size of packet \n\t\t\t\t\t\t(inSrcPort,size) = struct.unpack('!HH',head)\n\t\t\t\t\t\tif debug \u003e 3: print \"\u003c L Received: \", \"inSrcPort: \", inSrcPort, \"size: \", size,\"\\n\\t\", struct.unpack('!HH',head)\n\n\t\t\t\t\t\tif size \u003e 0:\n\t\t\t\t\t\t\tdata = self.sockReceive(s,size)\n\t\t\t\t\t\t\toutSock=self.findISocket(inSrcPort,SocketDict)\n\t\t\t\t\t\t\tif outSock:\n\t\t\t\t\t\t\t\toutSock.send(data)\n\t\t\t\t\t\t\telse: # In socket not in list - Try Socks\n\t\t\t\t\t\t\t\tif debug \u003e 4: print \"[D] Starting Connection Thread\"\n\t\t\t\t\t\t\t\tThread = threading.Thread(\n\t\t\t\t\t\t\t\t\ttarget=self.establishConnection, args=(s,data,sockets,SocketDict,inSrcPort)\n\t\t\t\t\t\t\t\t\t).start()\n\t\t\t\t\t\t\t\t#self.establishConnection(s,data,sockets,SocketDict,inSrcPort)\n\t\t\t\t\t\telse: #inSrcPort send no data - Port Closed \n\t\t\t\t\t\t\tif debug \u003e 3: print \"\\t Close Socket: \", inSrcPort\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\toutSock=self.findISocket(inSrcPort,SocketDict)\n\t\t\t\t\t\t\tif outSock:\n\t\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\tself.deleteISocket(outSock,SocketDict,sockets)\n\t\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\t\t\toutSock.close()\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telse: # Input socket not in list ?\n\t\t\t\t\t\t\t\tif debug \u003e 3: print \"[E] Received empty \u0026 socket not in list: \", inSrcPort\n\t\t\t\t\telse: # Other sockets (outSockets)\n\t\t\t\t\t\tdata = s.recv(self.bufferSize) \n\t\t\t\t\t\tif debug \u003e 3: print \"\u003e R Received: Data (client -\",self.srcPort(s),\") :\" , len(data) \n\t\t\t\t\t\t\n\t\t\t\t\t\tif data: \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif debug \u003e 3: print \"\\t sending to:\", SocketDict[self.srcPort(s)][0],\"len\", len(data)\n\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel locking 1\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\twrapper_channel.send((struct.pack('!HH',SocketDict[self.srcPort(s)][0],len(data))+data))\n\t\t\t\t\t\t\texcept (TypeError,socket.error, KeyError) as e:\n\t\t\t\t\t\t\t\tprint \"[-] Send Failed:\", e\n\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel releasing 1\"\n\t\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\t\n\t\t\t\t\t\tif len(data)==0:\n\t\t\t\t\t\t\tif debug \u003e 3: print \"\\tClosing port: \", SocketDict[self.srcPort(s)][0],'len:', len(data),\"Local Port:\", self.srcPort(s)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel locking 2\"\n\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\twrapper_channel.send((struct.pack('!HH',SocketDict[self.srcPort(s)][0],len(data)))) \t#send empty to lSrc will close the socket on the other end\n\t\t\t\t\t\t\texcept (TypeError,socket.error, KeyError) as e :\n\t\t\t\t\t\t\t\tself.printError(e)\n\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\tif debug \u003e4: print \"[T] Write to channel releasing 2\"\n\t\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\tself.deleteISocket(s,SocketDict,sockets)\n\t\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\t\tself.lock.release()\n\n\t\t\t\t\t\t\ts.close()\n\t\t\t\texcept struct.error as e:\n\t\t\t\t\tprint \"[-] Received malformed packet: Closing Socks Proxy\"\n\t\t\t\t\tsys.exit()\n\t\t\t\texcept socket.error as e:\t#Kill misbehaving socket\n\t\t\t\t\tself.printError(e)\n\t\t\t\t\ttry:\n\t\t\t\t\t\tself.lock.acquire()\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tself.deleteISocket(s,SocketDict,sockets)\n\t\t\t\t\t\tfinally:\n\t\t\t\t\t\t\tself.lock.release()\n\t\t\t\t\t\ts.close()\n\t\t\t\t\texcept:\n\t\t\t\t\t\tpass\t\t\n\t\t\t\t\tpass\t\n\t\twrapper_channel.close()\n\n\tdef __del__(self):\n\t\tif hasattr(self,\"sockets\"):\n\t\t\tfor s in self.sockets:\n\t\t\t\ts.close()\n\t\t\t\t\ndef banner():\n\tprint \"   _____            _         _____                          \"\n\tprint \"  / ____|          | |       / ____|                         \"\n\tprint \" | (___   ___   ___| | _____| (___   ___ _ ____   _____ _ __ \"\n\tprint \"  \\\\___ \\\\ / _ \\\\ / __| |/ / __|\\\\___ \\\\ / _ \\\\ '__\\\\ \\\\ / / _ \\\\ '__|\"\n\tprint \"  ____) | (_) | (__|   \u003c\\\\__ \\\\____) |  __/ |   \\\\ V /  __/ |   \"\n\tprint \" |_____/ \\\\___/ \\\\___|_|\\\\_\\\\___/_____/ \\\\___|_|    \\\\_/ \\\\___|_|  \"\n\tprint \"\"\n\n\tprint  \"SocksServer v1.1a, for Proxying TCP connections by Nikos Vassakis\"\n\tprint  \"http://www.secforce.com / nikos.vassakis \u003cat\u003e secforce.com\"\n\tprint \"###############################################################\"\n\tprint \"\"\t\n\t\nif __name__ == '__main__':\n\tif DEBUG \u003e 2: banner()\n\toptions={}\n\t\n\tif sys.argv \u003c 1:\n\t\tusage()\n\t\tsys.exit(2)\n\telse:\n\t\toptions['webServerPort']=int(sys.argv[1])\n\t\t#TODO: Parse Arguments\n\t\toptions=dict(Defaults.items() + options.items()) if options else Defaults\n\n\t\tSocksServerSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) \n\t\tSocksServerSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\t\tSocksServerSocket.bind((options['hostname'],options['webServerPort'])) \n\n\t\tS=SocksServer(SocksServerSocket)\n\t\t\n\t\ttry:\n\t\t\tS.run()\t\n\t\texcept KeyboardInterrupt:\n\t\t\tif DEBUG \u003e 0: print \"[S] Shutting Down SocksServer\" \n\t\t\tsys.exit(9)\n",
        "start-tunna.sh": "#!/bin/bash\ncd /opt/tunna\ncurl -sk $TUNNA_URL\nret=$?\nwhile [ $ret -ne 0 ];\ndo\n   echo \"Cannot connect to $TUNNA_URL yet\"\n   sleep 3\n   curl -sk $TUNNA_URL\n   ret=$?\ndone\npython proxy.py -u $TUNNA_URL -l $TUNNA_PORT 2\u003e\u00261 \u003e/dev/stdout"
    },
    "kind": "ConfigMap",
    "metadata": {
        "creationTimestamp": null,
        "name": "tunna",
        "selfLink": "/api/v1/namespaces/jdg-test2/configmaps/tunna"
    }
}
